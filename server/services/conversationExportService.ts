/**
 * Conversation Export Service
 * 
 * Handles exporting conversations in multiple formats (PDF, Markdown, JSON).
 * Supports including or excluding conversation based on user choice.
 * 
 * Requirements: 5.5
 */

import { db } from '../db';
import { searches, searchResults, conversations, conversationMessages } from '@shared/schema';
import { eq, desc } from 'drizzle-orm';
import { format } from 'date-fns';

interface ExportOptions {
  includeConversation: boolean;
  format: 'pdf' | 'markdown' | 'json';
}

interface ExportData {
  analysis: {
    query: string;
    timestamp: Date;
    innovationScore?: number;
    feasibilityRating?: string;
    gaps: Array<{
      title: string;
      category: string;
      description: string;
      innovationScore: number;
      feasibility: string;
    }>;
  };
  conversation?: {
    messageCount: number;
    messages: Array<{
      role: 'user' | 'assistant';
      content: string;
      timestamp: Date;
      metadata?: any;
    }>;
  };
}

/**
 * Get export data for a conversation
 */
export async function getExportData(
  conversationId: number,
  includeConversation: boolean
): Promise<ExportData> {
  // Get conversation
  const [conversation] = await db
    .select()
    .from(conversations)
    .where(eq(conversations.id, conversationId))
    .limit(1);

  if (!conversation) {
    throw new Error('Conversation not found');
  }

  // Get analysis
  const [analysis] = await db
    .select()
    .from(searches)
    .where(eq(searches.id, conversation.analysisId))
    .limit(1);

  if (!analysis) {
    throw new Error('Analysis not found');
  }

  // Get analysis results
  const results = await db
    .select()
    .from(searchResults)
    .where(eq(searchResults.searchId, analysis.id))
    .orderBy(desc(searchResults.innovationScore))
    .limit(10);

  const exportData: ExportData = {
    analysis: {
      query: analysis.query,
      timestamp: new Date(analysis.timestamp),
      innovationScore: results.length > 0 
        ? Math.round(results.reduce((sum, r) => sum + (r.innovationScore || 0), 0) / results.length)
        : undefined,
      feasibilityRating: results.length > 0 ? results[0].feasibility : undefined,
      gaps: results.map(r => ({
        title: r.title,
        category: r.category,
        description: r.description || '',
        innovationScore: r.innovationScore || 0,
        feasibility: r.feasibility || 'Unknown',
      })),
    },
  };

  // Include conversation if requested
  if (includeConversation) {
    const messages = await db
      .select()
      .from(conversationMessages)
      .where(eq(conversationMessages.conversationId, conversationId))
      .orderBy(conversationMessages.createdAt);

    exportData.conversation = {
      messageCount: messages.length,
      messages: messages.map(m => ({
        role: m.role as 'user' | 'assistant',
        content: m.content,
        timestamp: new Date(m.createdAt),
        metadata: m.metadata,
      })),
    };
  }

  return exportData;
}

/**
 * Export conversation as Markdown
 */
export function exportAsMarkdown(data: ExportData): string {
  let markdown = '';

  // Header
  markdown += `# Gap Analysis Report\n\n`;
  markdown += `**Query:** ${data.analysis.query}\n\n`;
  markdown += `**Date:** ${format(data.analysis.timestamp, 'PPP')}\n\n`;

  if (data.analysis.innovationScore !== undefined) {
    markdown += `**Innovation Score:** ${data.analysis.innovationScore}/100\n\n`;
  }

  if (data.analysis.feasibilityRating) {
    markdown += `**Feasibility:** ${data.analysis.feasibilityRating}\n\n`;
  }

  // Gaps
  markdown += `## Identified Gaps\n\n`;
  data.analysis.gaps.forEach((gap, index) => {
    markdown += `### ${index + 1}. ${gap.title}\n\n`;
    markdown += `**Category:** ${gap.category}\n\n`;
    markdown += `**Innovation Score:** ${gap.innovationScore}/100\n\n`;
    markdown += `**Feasibility:** ${gap.feasibility}\n\n`;
    markdown += `${gap.description}\n\n`;
    markdown += `---\n\n`;
  });

  // Conversation
  if (data.conversation) {
    markdown += `## Conversation History\n\n`;
    markdown += `**Total Messages:** ${data.conversation.messageCount}\n\n`;

    data.conversation.messages.forEach((message, index) => {
      const role = message.role === 'user' ? 'You' : 'AI Assistant';
      const timestamp = format(message.timestamp, 'PPp');
      
      markdown += `### ${role} - ${timestamp}\n\n`;
      markdown += `${message.content}\n\n`;
      
      if (index < data.conversation!.messages.length - 1) {
        markdown += `---\n\n`;
      }
    });
  }

  // Footer
  markdown += `\n---\n\n`;
  markdown += `*Generated by Unbuilt - ${format(new Date(), 'PPP')}*\n`;

  return markdown;
}

/**
 * Export conversation as JSON
 */
export function exportAsJSON(data: ExportData): string {
  return JSON.stringify(data, null, 2);
}

/**
 * Export conversation as PDF (placeholder - requires PDF library)
 * For now, returns markdown that can be converted to PDF on the client
 */
export function exportAsPDF(data: ExportData): string {
  // TODO: Implement actual PDF generation using a library like pdfkit or puppeteer
  // For now, return markdown that can be converted to PDF on the client side
  return exportAsMarkdown(data);
}

/**
 * Main export function
 */
export async function exportConversation(
  conversationId: number,
  options: ExportOptions
): Promise<{ content: string; filename: string; mimeType: string }> {
  const data = await getExportData(conversationId, options.includeConversation);

  let content: string;
  let filename: string;
  let mimeType: string;

  const timestamp = format(new Date(), 'yyyy-MM-dd-HHmmss');
  const baseFilename = `unbuilt-analysis-${conversationId}-${timestamp}`;

  switch (options.format) {
    case 'markdown':
      content = exportAsMarkdown(data);
      filename = `${baseFilename}.md`;
      mimeType = 'text/markdown';
      break;

    case 'json':
      content = exportAsJSON(data);
      filename = `${baseFilename}.json`;
      mimeType = 'application/json';
      break;

    case 'pdf':
      content = exportAsPDF(data);
      filename = `${baseFilename}.pdf`;
      mimeType = 'application/pdf';
      break;

    default:
      throw new Error(`Unsupported export format: ${options.format}`);
  }

  return { content, filename, mimeType };
}
